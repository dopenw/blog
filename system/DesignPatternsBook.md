# 设计模式 - 可复用面向对象软件的基础


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [设计模式 - 可复用面向对象软件的基础](#设计模式-可复用面向对象软件的基础)
  - [第一章 引言](#第一章-引言)
    - [1.1 什么是设计模式](#11-什么是设计模式)
    - [1.2 Smalltalk MVC 中的设计模式](#12-smalltalk-mvc-中的设计模式)
    - [1.3 描述设计模式](#13-描述设计模式)

<!-- /code_chunk_output -->



## 第一章 引言

### 1.1 什么是设计模式
一般而言，一个模式有四个基本要素：
- `模式名`(pattern name)，一个助记名，它用一两个词来描述模式的问题、解决方案和效果。
- `问题`(problem), 描述了应该在何时使用模式。
- `解决方案`(solution)描述了设计的组成部分、他们之间的相互关系及各自的职责和协作方式。
- `效果`(consequence)描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要的意义。

本书中的设计模式是 `对用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。`

### 1.2 Smalltalk MVC 中的设计模式
在 [Smalltalk-80](https://en.wikipedia.org/wiki/Smalltalk) 中，类的模型/视图/控制器（Model/view/Controller）三元组(MVC)被用来构建用户界面。透过 MVC 来看设计模式将帮助我们理解 “模式”这一术语的含义。

若不使用 MVC ，用户界界面设计往往将这些对象混在一起，而 MVC 则将它们分离以提高灵活性和复用性。
MVC 通过建立一个 “订购/通知” 协议来分离视图和模型。视图必须保证它的显示正确地反映了模型的状态。一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。这种方法可以让你为一个模型提供不同的多个视图表现形式，也能够为一个模型创建新的视图而无须重写模型。

下图显示了一个模型和三个视图（为了简单我们省略了控制器）。

![](../images/DesignPatternsBook_202112181611_1.png)

表面上看，这个例子反映了将视图和模型分离的设计，然而这个设计还可用于解决更一般的问题：将对象分离，使得一个对象的改变能够影响另一些对象，而这个对象并不需要知道那些被影响的对象的细节。这个更一般的设计被描述成 Observer 模式。

MVC 的另一个特征是视图可以嵌套。例如，按钮控制面板可以用一个嵌套了按钮的复杂视图来实现。MVC 用 view 类的子类 -- compositeView 类来支持嵌套视图。

上例反映了可以将组合视图与其构件平等对待的设计，同样，该设计也适用于更一般的问题：将一些对象划为一组，并将该组对象当作一个对象来使用。这个设计被描述成 Composite 模式。 

MVC 允许你在不改变视图外观的情况下改变视图对用户输入的响应方式。例如，你可能希望改变视图对键盘的响应方式，或希望使用弹出菜单而不是原来的命令键方式。MVC 将响应机制封装在 Controller 对象中。存在着一个 Controller 的类层次结构，使得可以方便地对原有 Controller 做适当改变而创建新的 Controller

View-Controller 关系是 Strategy 模式的一个例子。一个策略是一个表述算法的对象。当你想静态或动态地替换一个算法，或你有很多不同的算法，或算法中包含你想封装的复杂数据结构时，策略模式是非常有用的。

MVC 还使用了其他的设计模式，如：用来指定视图默认控制器的 Factory Method 和用来增加视图滚动的 Decorator 。但是 MVC 的主要关系还是 Observer 、 Composite 和 Strategy 三个设计模式给出的。

### 1.3 描述设计模式 

我们将用统一的格式描述设计模式，有助于你更容易地学习、比较和使用设计模式。
- `模式名和分类` 
- `意图`
- `别名`
- `动机`
- `适用性`
- `结构`
- `参与者`，指设计模式中的类和/或对象以及它们各自的职责。
- `协作`，模式的参与者怎样协作以实现它们的职责
- `效果`
- `实现`
- `代码示例`
- `已知应用`
- `相关模式`

---

- [上一级](README.md)
- 上一篇 -> [C 和 C++ 的内存分布](CAndC++MemoryDistribution.md)
- 下一篇 -> [贪心算法](GreedyAlgorithms.md)
