# 设计模式 - 可复用面向对象软件的基础

---
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [设计模式 - 可复用面向对象软件的基础](#设计模式---可复用面向对象软件的基础)
  - [第一章 引言](#第一章-引言)
    - [1.1 什么是设计模式](#11-什么是设计模式)
    - [1.2 Smalltalk MVC 中的设计模式](#12-smalltalk-mvc-中的设计模式)
    - [1.3 描述设计模式](#13-描述设计模式)
    - [1.4 设计默认的编目](#14-设计默认的编目)
    - [1.5 组织条目](#15-组织条目)
    - [1.6 设计模式怎样解决设计问题](#16-设计模式怎样解决设计问题)
      - [1.6.1 寻找合适的对象](#161-寻找合适的对象)
      - [1.6.2 决定对象的粒度](#162-决定对象的粒度)
      - [1.6.3 指定对象接口](#163-指定对象接口)
      - [1.6.4 描述对象的实现](#164-描述对象的实现)
      - [1.6.5 运用复用机制](#165-运用复用机制)
        - [继承和组合的比较](#继承和组合的比较)
        - [委托](#委托)
        - [继承和参数化类型的比较](#继承和参数化类型的比较)
      - [1.6.6 关联运行时和编译时的结构](#166-关联运行时和编译时的结构)
      - [1.6.7 设计应支持变化](#167-设计应支持变化)
    - [1.7 怎样选择设计模式](#17-怎样选择设计模式)
    - [1.8 怎样使用设计模式](#18-怎样使用设计模式)

<!-- /code_chunk_output -->

---

## 第一章 引言

### 1.1 什么是设计模式

一般而言，一个模式有四个基本要素：

- `模式名`(pattern name)，一个助记名，它用一两个词来描述模式的问题、解决方案和效果。
- `问题`(problem), 描述了应该在何时使用模式。
- `解决方案`(solution)描述了设计的组成部分、他们之间的相互关系及各自的职责和协作方式。
- `效果`(consequence)描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要的意义。

本书中的设计模式是 `对用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。`

---

### 1.2 Smalltalk MVC 中的设计模式

在 [Smalltalk-80](https://en.wikipedia.org/wiki/Smalltalk) 中，类的模型/视图/控制器（Model/view/Controller）三元组(MVC)被用来构建用户界面。透过 MVC 来看设计模式将帮助我们理解 “模式”这一术语的含义。

若不使用 MVC ，用户界界面设计往往将这些对象混在一起，而 MVC 则将它们分离以提高灵活性和复用性。
MVC 通过建立一个 “订购/通知” 协议来分离视图和模型。视图必须保证它的显示正确地反映了模型的状态。一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。这种方法可以让你为一个模型提供不同的多个视图表现形式，也能够为一个模型创建新的视图而无须重写模型。

下图显示了一个模型和三个视图（为了简单我们省略了控制器）。

![](../images/DesignPatternsBook_202112181611_1.png)

表面上看，这个例子反映了将视图和模型分离的设计，然而这个设计还可用于解决更一般的问题：将对象分离，使得一个对象的改变能够影响另一些对象，而这个对象并不需要知道那些被影响的对象的细节。这个更一般的设计被描述成 Observer 模式。

MVC 的另一个特征是视图可以嵌套。例如，按钮控制面板可以用一个嵌套了按钮的复杂视图来实现。MVC 用 view 类的子类 -- compositeView 类来支持嵌套视图。

上例反映了可以将组合视图与其构件平等对待的设计，同样，该设计也适用于更一般的问题：将一些对象划为一组，并将该组对象当作一个对象来使用。这个设计被描述成 Composite 模式。

MVC 允许你在不改变视图外观的情况下改变视图对用户输入的响应方式。例如，你可能希望改变视图对键盘的响应方式，或希望使用弹出菜单而不是原来的命令键方式。MVC 将响应机制封装在 Controller 对象中。存在着一个 Controller 的类层次结构，使得可以方便地对原有 Controller 做适当改变而创建新的 Controller

View-Controller 关系是 Strategy 模式的一个例子。一个策略是一个表述算法的对象。当你想静态或动态地替换一个算法，或你有很多不同的算法，或算法中包含你想封装的复杂数据结构时，策略模式是非常有用的。

MVC 还使用了其他的设计模式，如：用来指定视图默认控制器的 Factory Method 和用来增加视图滚动的 Decorator 。但是 MVC 的主要关系还是 Observer 、 Composite 和 Strategy 三个设计模式给出的。

---

### 1.3 描述设计模式

我们将用统一的格式描述设计模式，有助于你更容易地学习、比较和使用设计模式。

- `模式名和分类`
- `意图`
- `别名`
- `动机`
- `适用性`
- `结构`
- `参与者`，指设计模式中的类和/或对象以及它们各自的职责。
- `协作`，模式的参与者怎样协作以实现它们的职责
- `效果`
- `实现`
- `代码示例`
- `已知应用`
- `相关模式`

---

### 1.4 设计默认的编目

从第三章开始的模式目录中包含23个设计模式。如下所示：

- Abstract Factory(3.1): 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。
- Adapter(4.1): 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- Bridge(4.2): 将抽象部分与它的实现部分分离，使它们都可以独立的变化。
- Builder(3.2):将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- Chain of Responsibility(5.1):解除请求的发送者和接收者之间的耦合，使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
- Command(5.2): 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
- Composite(4.3):将对象组合成树形结构以表示“部分--整体”的层次结构。Composite 使得客户对单个对象和组合对象的使用具有一致性。
- Decorator(4.4):动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。
- Facade(4.5):为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- Factory Method(3.3)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。
- Flyweight(4.6):运用共享技术有效地支持大量细粒度的对象。
- Interpreter(5.3):给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
- Iterator(5.4):提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
- Mediator(5.5):用一个中介对象来封装一系列的对象交互。中介者使各个对象不用显式地相互调用，从而使其耦合松散，而且可以独立地改变他们之间的交互。
- Memento(5.6):在不破环封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。
- Observer(5.7):定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
- Prototype(3.4):用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
- Proxy(4.7):为其他对象提供一个代理以控制对这个对象的访问。
- Singleton(3.5):保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- State(5.8):允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
- Strategy(5.9):定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。
- Template Method(5.10):定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。
- Vistor(5.11):表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

---

### 1.5 组织条目

<table class="tg">
<thead>
  <tr>
    <th class="tg-g6va" rowspan="2"></th>
    <th class="tg-g6va" rowspan="2"></th>
    <th class="tg-6ltk" colspan="3">目的</th>
  </tr>
  <tr>
    <th class="tg-6ltk">创建型</th>
    <th class="tg-6ltk">结构型</th>
    <th class="tg-6ltk">行为型</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-uko8" rowspan="2">范围</td>
    <td class="tg-s4wa">类</td>
    <td class="tg-s4wa">Factory Method</td>
    <td class="tg-s4wa">Adapter</td>
    <td class="tg-s4wa">Interpreter<br>Template Method</td>
  </tr>
  <tr>
    <td class="tg-s4wa">对象</td>
    <td class="tg-s4wa">Abstract Factory<br>Builder<br>Prototype<br>Singleton</td>
    <td class="tg-s4wa">Adapter<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy</td>
    <td class="tg-s4wa">Chain of Responsibility<br>Command<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Strategy<br>Visitor</td>
  </tr>
</tbody>
</table>

我们根据两条准则对模式进行分类。第一条是`目的`准则，即模式是用来完成什么工作的。模式依据其目的可分为：

- 创建型（与对象的创建有关）
- 结构型（处理类与对象的组合）
- 行为型模式（对类或对象怎么交互和怎么分配职责进行描述）。
第二条是`范围`准则，指定模式主要是用于类还是用于对象。`类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时便确定下来了`。`对象模式处理对象间的关系,这些关系在运行时是可以变化的，更具动态性。`从某种意义上来说，几乎所有模式都是用继承机制，所以 “类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。

还有一种方式是根据模式的“相关模式”部分所描述的它们怎么互相引用来组织设计模式。如下图所示：

![](../images/DesignPatternsBook_202112251755_1.png)

显然，存在着许多组织设计模式的方法。从多角度去思考模式有助于对它们的功能、差异和应用场合的更深入理解。

---

### 1.6 设计模式怎样解决设计问题

设计模式采用多种方法解决面向对象设计者经常碰到的问题。这里给出几个问题以及使用设计模式解决它们的方法。

#### 1.6.1 寻找合适的对象

面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等，它们都影响着系统的分解，并且这些因素通常还是互相冲突的。
面向对象设计方法学支持许多设计方法。你可以写成一个问题描述，挑出名词和动词，进而创建相应的类和操作；或者，你可以关注系统的协作和职责关系；或者你可以对现实世界建模，再将分析时发现的对象转化至设计中。至于哪一种方法最好，并无定论。

---

#### 1.6.2 决定对象的粒度

对象在大小和数目上变化极大。它们能表示下至硬件或上至整个应用的任何事物。那么我们怎样决定一个对象应该是什么呢？
设计模式很好的讲述了这个问题。Facade 模式描述了怎样用对象表示完整的子系统，Flyweight 模式描述了如何支持大量的最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。Abstract Factory 和 Builder 产生那些专门负责生成其他对象的对象。Visitor 和 Command 生成的对象专门负责实现对其他对象或对象组的请求。

---

#### 1.6.3 指定对象接口

设计模式通过确定接口的主要组成成分以及经接口发送的数据类型来帮助你定义接口。设计模式也许还会告诉你接口中不应包括哪些东西。Memento 模式是一个很好的例子，它描述了怎样封装和保存对象内部的状态，以便一段时间后对象能恢复到这一状态。它规定了 Memento 对象必须定义两个接口：一个允许客户保持和复制 Memento 的限制接口，一个只有原对象才能使用的用来储存和提取 Memento 中状态的特权接口。
设计模式也指定了接口之间的关系。特别是，它们经常要求一些类具有相似的接口，或它们对一些类的接口做了限制。例如，Decorator 和 Proxy 模式分别要求 Decorator 和 Proxy 对象的接口与被修饰的对象和受委托的对象一致。而 Visitor 模式中，Visitor 接口必须反映出 Visitor 能访问的对象的所有类。

---

#### 1.6.4 描述对象的实现

对象的实现是由它的类决定的，类指定了对象的内部数据和表示，也定义了对象所能完成的操作，如下图所示：

![](../images/DesignPatternsBook_202112262239_1.png)

我们基于 OMT 的表示法(OMT由Rumbaugh于1991年开发，作为一种广泛用于软件开发的对象建模方法。 OMT被认为是统一建模语言（UML）的前身。 因此，许多OMT建模元素与UML建模元素相似。[Object-modeling technique](https://en.wikipedia.org/wiki/Object-modeling_technique))，将类描述成一个矩形，其中的类名以黑体表示。操作在类名下面，以常规字体表示。类所定义的任何数据都在操作的下面。类名与操作之间以及操作与数据之间用横线分隔。
返回类型和实例变量类型是可选的，因为我们并未假设一定要用具有静态类型的实现语言。
对象通过实例化类来创建，此对象被称为该类的实例。就像这样：

![](../images/DesignPatternsBook_202112262239_2.png)

我们以竖线和三角表示子类关系，如下图所示：

![](../images/DesignPatternsBook_202112262239_3.png)

抽象类的类名以斜体表示，以与具体类相区别。抽象操作也用斜体表示。图中可以包括实现操作的伪代码，如果这样，则代码将出现在带有褶角的框中，并用虚线将该褶角框与代码所示实现的操作相连，如下图所示：

![](../images/DesignPatternsBook_202112262324_1.png)

`混入类`(mixin class)是给其他类提供可选择的接口或功能的类。它与抽象类一样不能实例化。图示如下：

![](../images/DesignPatternsBook_202201022114_1.png)

1. 类继承与接口继承的比较
   理解对象的类与对象的类型之间的差别很重要。
   对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。但是对象的类型只与它的接口有关，接口即对象能响应的请求的集合。一个对象可以有多个类型，不同类的对象可以有相同的类型。

2. 对接口编程而不是对实现编程
    但继承被恰当使用时，所有从抽象类导出的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型。
    只是根据抽象类中定义的接口来操纵对象有以下两个好处：
    1. 客户无须知道他们使用对象的特定类型，只需要知道对象有客户所期望的接口。
    2. 客户无须知道他们使用的对象是用什么类来实现的，只需要知道定义接口的抽象类。
    这将极大地减少子系统实现之间的相互依赖关系，也产生了可复用的面向对象设计的如下原则：
    针对接口编程，而不是针对实现编程。

---

#### 1.6.5 运用复用机制

理解对象、接口、类和继承之类的概念对大多数人来说并不难，问题的关键在于如何运用它们写出灵活的、可复用的软件。

##### 继承和组合的比较

面向对象系统中功能复用的两种最常用的技术是类继承和对象组合。

- 类继承通过生成子类的复用通常被称为`白箱复用`。术语“白箱”是相对可视性而言的：在继承方式中，父类的内部细节对于子类可见。
- 对象组合是一种通过组装或组合对象的一种更复杂的功能。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为`黑箱复用`，因为对象的内部细节是不可见的。

继承和组合各有优缺点。类继承是在编译时静态定义的，且可直接使用，因为程序设计语言直接支持类继承。类继承可以较方便地改变被复用的实现。
但是类也有一些不足之处。首先，因为继承在编译时就定义了，所以无法在运行时改变从父类继承的实现。更糟的是，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的实现细节，所以继承常被认为“破坏了封装性”。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。
当你需要复用子类时，实现上的依赖就会产生一些问题。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。一个可用的解决方法就是只继承抽象类，因为抽象类通常提供较少的实现。
对象组合是通过获得对其他对象的引用而在运行时动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。这还会产生良好的结果：因为对象只能通过接口访问，所以我们并不破环封装性；只要类型一致，运行时还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。
对象组合对系统设计还有另一个作用，即优先使用对象组合有助于你保持每一个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。另外，基于对象组合的设计会有更多的对象（而有较少的类），且系统的行为将依赖于对象间的关系而不是被定义在某个类中。
这导出了我们的面向对象设计的第二个原则：
`优先使用对象组合，而不是类继承`

##### 委托

委托(delegation) 是一种组合方法，它使组合具有与继承同样的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者(delegate)。这类似于子类将请求交给它的父类处理。委托方式为了得到同样的效果，接受请求的对象将自己传给被委托者（代理者），使被委托的操作可以引用接受请求的对象。

eg：下面的图显示了窗口类将它的 Area 操作委托给一个矩形实例。

![](../images/DesignPatternsBook_202201022114_2.png)

箭头线表示一个类对另一个类实例的引用关系。引用名师可选的，本例为 "rectangle".

委托的主要优点在于它便于运行时组合对象操作以及改变这些操作的组合方式。假定矩形对象和圆对象有相同的类型，我们只需要简单地用圆对象替换矩形对象，得到的窗口就是圆形的。

委托与那些通过对象组合取得软件灵活性的技术一样，具有如下不足之处：动态的、高度参数化的软件比静态软件更难于理解。还有运行低效的问题，不过从长远来看人的低效才是最主要的。只有当委托使设计比较简单而不是更复杂时，它才是好的选择。

有一些模式使用了委托：如 State 、 Strategy 、Visitor 。

委托是对象组合的特例。它告诉你对象组合作为一个代码复用机制可以替代继承。

##### 继承和参数化类型的比较

另一种功能复用技术（并非严格的面向对象技术）是``参数化类型`(parameterized type),也就是`类属`(generic)(Ada、Eiffel)或`模板`(Template)(c++)。

许多设计可以使用这三种技术中的任何一种来实现。实现一个以元素比较操作为可变元的排序例程，可使用如下方法：

1. 通过子类实现该操作(Template Method 的一个应用)
2. 实现要传给排序例程的对象的职责(Strategy)
3. 作为 c++ 模板或 Ada 类属的参数，以指定元素比较操作的名称。

---

#### 1.6.6 关联运行时和编译时的结构

一个面向对象程序运行时的结构通常与它的代码结构相差较大。代码结构在编译时就被确定下来了，它由继承关系固定的类组成。而程序的运行结构是由快速变化的通信对象网络组成的。事实上两个结构是彼此独立的。

考虑对象`聚合`(aggregation) 和 `相识`(acquaintance) 的差别以及它们在编译时和运行时的表示有多么不同。聚合意味着一个对象拥有另一个对象或对另一个对象负责。一般我们称一个对象`包含`另一个对象或者是另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期。
相识意味着一个对象仅仅知道另一个对象。有时相识也被称为 “关联” 或 “引用” 关系，相识的对象可能请求彼此的操作，但是它们不为彼此负责。相识是一种比聚合要弱的关系，它只是标识了对象间较松散的耦合关系。

在下图中，普通的箭头线表示相识，尾部带有菱形的箭头表示聚合：

![](../images/DesignPatternsBook_202201031519_1.png)

聚合和相识很容易混淆，因为它们通常以相同的方法实现。在 C++ 中，聚合可以通过定义表示真正示例的成员变量来实现，但更通常的是将这些成员变量定义为实例指针或引用；相识也是以指针或引用来实现的。

从根本上来讲，是聚合还是相识是由你的意图而不是显式的语言机制决定的。聚合关系使用较少且比相识关系更持久；而相识关系则出现频率较高，但有时只存在于一个操作期间，相识也更具动态性，使得它在源代码中更难被分辨出来。

许多设计模式（特别是那些属于对象范围的）显式地记述了编译时和运行时结构的差别。Composite 和 Decorator 对于构造复杂的运行时结构非常有用。Observer 也与运行时结构有关，但这些结构对于不了解该模式的人来说是很难理解的。Chain of Responsibility 也产生了继承所无法展现的通信模式，总之，只有理解了模式，你才能清楚代码中的运行时结构。

---

#### 1.6.7 设计应支持变化

获得最大限度复用的关键在于对新需求和已有需求发生变化时的预见性。要求你的系统设计能够相应地改进。
为了设计适应这种变化且具有健壮性的系统，你必须考虑系统在它的生命周期内会发生怎样的变化。一个不考虑系统变化的设计在将来就有可能需要重新设计。重新设计会影响软件系统的许多方面，并且未曾料到的变化总是代价巨大的。
设计模式可以确保系统以特定方式变化，从而帮助你避免重新设计系统。
下面阐述了一些导致重新设计的一般原因，以及解决这些问题的设计模式：

- `通过显式地指定一个类来创建对象` 在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。
  设计模式： Abstract Factory,Factory Method,Prototype
- `对特殊操作的依赖` 当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免请求代码写死，你将可以在编译时或运行时很方便地改变响应请求的方法。
  设计模式： Chain of Responsibility ,Command
- `对硬件和软件平台的依赖` 外部的操作系统接口和应用编程接口(API)在不同的软硬件平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。
  设计模式：Abstract Factory,Bridge
- `对对象表示或实现的依赖` 知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。
  设计模式： Abstract Factory,Bridge,Memento,Proxy
- `算法依赖` 算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。
  设计模式： Builder,Iterator,Strategy,Template Method,Visitor
- `紧耦合` 紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删除一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。
  松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。
  设计模式： Abstract Factory,Command,Facade,Mediator,Observer,Chain of Responsibility
- `通过生成子类来扩充功能` 通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等)。定义子类还需要对父类有深入的了解。
  一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方式。另一方面，过多使用对象组合会使设计难于理解。
  设计模式： Bridge,Chain of Responsibility,Composite,Decorator,Observer,Strategy
- `不能方便地对类进行修改` 有时你不得不改变一个难以修改的类。
  设计模式： Adapter,Decorator,Visitor

这些例子放映了使用设计模式有助于增强软件的灵活性。这种灵活性所具有的重要程度取决于你将要建造的软件系统。让我们看一看设计模式在开发如下三类主要软件中所起的作用：应用程序、工具箱和框架。

1. 应用程序
   如果你将要建造像文档编辑器或电子制表软件这样的应用程序，那么它的`内部复用性、可维护性和可扩充性`是要优先考虑的。
2. 工具箱
   一个应用经常会使用来自一个或多个被称为工具箱(toolkit) 的预定义类库中的类。工具箱是一组相关的、可复用的类的集合，这些类提供了通用的功能。工具箱的一个典型例子就是列表、关联表单、堆栈等类的集合，c++ 的 I/O 流库是另一个例子。工具箱强调的是`代码复用`,它们是面向对象环境下的 “子程序库”。
   工具箱的设计比应用设计要难得多，因为它要求对许多应用是可用的和有效的。
3. 框架
   框架是构成一类特定软件的可复用设计的一组相互协作的类。
   框架规定了你的应用的体系结构。它定义了整体结构，类和对象的划分，各部分的主要责任，类和对象怎么协作，以及控制流程。框架与定义了这些设计参数，以便应用设计者或实现者能集中精力于应用本身的特定细节。框架记录了其应用领域的共同的设计决策。因而框架更强调`设计复用`，尽管框架常包括具体的立即可用的子类。
   这个层次的复用导致了应用和它所基于的软件之间的反向控制 (inversion of control).当使用工具箱（或传统的子程序库）时，你需要写应用软件的主体并且调用你想复用的代码。而当使用框架时，你应该复用应用的主体，写主体调用的代码。你不得不以特定的名字和调用约定来写操作的实现，而这会减少你需要做出的设计决策。
   如果说应用程序难以设计，那么工具箱就更难了，而框架则是最难的。框架设计者必须冒险决定一个要适应该领域的所有应用的体系结构。任何对框架设计的实质性修改都会大大降低框架所带来的好处，因为框架对应用的最主要贡献在于它所定义的体系结构。因此设计的框架必须尽可能地灵活、可扩充。
   框架和设计模式有些类似，最主要的不同在于如下三个方面：
   1. `设计模式比框架更抽象`
   2. `设计模式是比框架更小的体系结构元素`
   3. `框架比设计模式更加特例化` 框架总是针对一个特定的应用领域。

---

### 1.7 怎样选择设计模式

这里给出几个不同的方法，以帮助你发现适合你手头问题的设计模式：

- `考虑设计模式是怎样解决设计问题的` 参考[1.6 节](#16-设计模式怎样解决设计问题)的讨论
- `浏览模式的意图部分` [1.4 节](#14-设计默认的编目) 列出了目录中所有模式的意图部分。通读每个模式的意图，找出和你的问题相关的一个或多个模式。你可以使用 [1.5 节](#15-组织条目)表所显示的分类方法缩小你的搜查范围。
- `研究模式怎样互相关联` [1.5 节](#15-组织条目)图以图形的方式显示了设计模式之间的关系。这些关系能指导你获得合适的模式或模式组。
- `研究目的相似的模式` 模式分类描述部分共有三章，一章介绍创建型模式，一章介绍结构型模式，一章介绍行为型模式。每一章以对模式介绍性的评价开始，以一个小节的比较和对照结束。这些小节使你得以洞察具有相似目的的模式之间的共同点和不同点。
- `检查重新设计的原因` 看一看 [1.6.7 设计应支持变化](#167-设计应支持变化)开始讨论的引起重新设计的各种原因，看看你的问题是否与它们有关，然后再找出哪些模式可以帮助你避免这些会导致重新设计的因素。
- `考虑你的设计中哪些是可变的` 这个方法与关注引起重新设计的原因刚好相反。它不是考虑什么会迫使你的设计改变，而是考虑你想要什么变化却又不会引起重新设计。最主要的一点是 `封装变化的概念`，这是许多设计模式的主题。下表列出了设计模式允许你独立变化的方面，你可以改变它们而又不会导致重新设计。

<table class="tg" style="undefined;table-layout: fixed; width: 944px">
<colgroup>
<col style="width: 119px">
<col style="width: 206px">
<col style="width: 619px">
</colgroup>
<thead>
  <tr>
    <th class="tg-baqh">目的</th>
    <th class="tg-baqh">设计模式</th>
    <th class="tg-baqh">可变的方面</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-nrix" rowspan="5">创建</td>
    <td class="tg-0lax">Abstract Factory</td>
    <td class="tg-0lax">产品对象家族</td>
  </tr>
  <tr>
    <td class="tg-0lax">Builder</td>
    <td class="tg-0lax">如何创建一个组合对象</td>
  </tr>
  <tr>
    <td class="tg-0lax">Factory Method</td>
    <td class="tg-0lax">被实例化的子类</td>
  </tr>
  <tr>
    <td class="tg-0lax">Prototype</td>
    <td class="tg-0lax">被实例化的类</td>
  </tr>
  <tr>
    <td class="tg-0lax">Singleton</td>
    <td class="tg-0lax">一个类的唯一实例</td>
  </tr>
  <tr>
    <td class="tg-nrix" rowspan="7">结构</td>
    <td class="tg-0lax">Adapter</td>
    <td class="tg-0lax">对象的接口</td>
  </tr>
  <tr>
    <td class="tg-0lax">Bridge</td>
    <td class="tg-0lax">对象的实现</td>
  </tr>
  <tr>
    <td class="tg-0lax">Composite</td>
    <td class="tg-0lax">一个对象的结构和组成</td>
  </tr>
  <tr>
    <td class="tg-0lax">Decorator</td>
    <td class="tg-0lax">对象的职责，不生成子类</td>
  </tr>
  <tr>
    <td class="tg-0lax">Facade</td>
    <td class="tg-0lax">一个子系统的接口</td>
  </tr>
  <tr>
    <td class="tg-0lax">FlyWeight</td>
    <td class="tg-0lax">对象的存储开销</td>
  </tr>
  <tr>
    <td class="tg-0lax">Proxy</td>
    <td class="tg-0lax">如何访问一个对象；该对象的位置</td>
  </tr>
  <tr>
    <td class="tg-nrix" rowspan="11">行为</td>
    <td class="tg-0lax">Chain of Responsibility</td>
    <td class="tg-cly1">满足一个请求的对象</td>
  </tr>
  <tr>
    <td class="tg-0lax">Command</td>
    <td class="tg-0lax">何时、怎样满足一个请求</td>
  </tr>
  <tr>
    <td class="tg-0lax">Interpreter</td>
    <td class="tg-0lax">一个语言的文法及解释</td>
  </tr>
  <tr>
    <td class="tg-0lax">Iterator</td>
    <td class="tg-0lax">如何遍历、访问一个聚合的各元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">Mediator</td>
    <td class="tg-0lax">对象间怎样交互、和谁交互</td>
  </tr>
  <tr>
    <td class="tg-0lax">Memento</td>
    <td class="tg-0lax">一个对象中哪些私有信息存放在该对象之外，以及在什么时候进行存储</td>
  </tr>
  <tr>
    <td class="tg-0lax">Observer</td>
    <td class="tg-0lax">多个对象依赖于另外一个对象，而这些对象又如何保持一致</td>
  </tr>
  <tr>
    <td class="tg-0lax">State</td>
    <td class="tg-0lax">对象的状态</td>
  </tr>
  <tr>
    <td class="tg-0lax">Strategy</td>
    <td class="tg-0lax">算法</td>
  </tr>
  <tr>
    <td class="tg-0lax">Template Method</td>
    <td class="tg-0lax">算法中的某些步骤</td>
  </tr>
  <tr>
    <td class="tg-0lax">Visitor</td>
    <td class="tg-0lax">某些可作用于一个（组）对象上的操作，但不修改这些对象的类</td>
  </tr>
</tbody>
</table>

---

### 1.8 怎样使用设计模式

一旦选择了一个设计模式，该怎么使用它呢？这里给出一个有效应用设计模式的循序渐进的方法。

1. `大致浏览一遍模式` 特别注意其适用性部分和效果部分，确定它适合你的问题
2. `回头研究结构部分、参与者部分和协作部分` 确保你理解这个模式的类和对象以及它们是怎样关联的。
3. `看代码示例部分，看看这个模式代码形式的具体例子` 研究代码将有助于你实现模式。
4. `选择模式参与者的名字，使它们在应用上下文中有意义`
5. `定义类`
6. `定义模式中专用于应用的操作名称` 这里再次体现出名字一般依赖于应用。使用每一个与操作相关联的责任和协作作为指导。还有，你的名字约定要一致。例如，可以使用 "Create-"前缀统一标记 Factory 方法。
7. `实现执行模式中责任和协作的操作` 实现部分提供线索指导你进行实现。代码示例部分的例子也能提供帮助。

关于设计模式，如果不提一下它们的使用限制，那么关于怎样使用它们的讨论就是不完整的。设计模式不能够随意使用。通常你通过引入额外的间接层次获得灵活性和可变性的同时，也使设计变得更复杂/或牺牲了一定的性能。一个设计模式只有当它提供的灵活性是真正需要的时候，才有必要使用。当衡量一个模式的得失时，它的效果部分是最能提供帮助的，如[1.7 怎样选择设计模式](#17-怎样选择设计模式)表所示。

---

- [上一级](README.md)
- 上一篇 -> [C 和 C++ 的内存分布](CAndC++MemoryDistribution.md)
- 下一篇 -> [贪心算法](GreedyAlgorithms.md)
